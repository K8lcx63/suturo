\documentclass{suturo}

\begin{document}
    \maketitle{Planning}{03.03.2018}{}{1}{}{}{}{}

\makeatletter
\newcommand{\chapterauthor}[1]{%
  {\parindent0pt\vspace*{-47pt}%
  \linespread{2.2}\large\begin{flushright}von: #1\end{flushright}%
  \par\nobreak\vspace*{0pt}}
  \@afterheading%
}
\makeatother

\section*{Zielsetzung}
Das Ziel von Gruppe Planning im zweiten Meilenstein ist zu einem die Kommunikationsschnittelle zwischen den anderen Gruppen zu sein, aber auch eigene wichtige Funktionalitäten hinzuzufügen. Planning selber ist für das Fahren zwischen den Tischen, das Errorhandling wenn ein Objekt nicht gegriffen werden kann oder runter fällt sowie das entscheiden wo ein Objekt genau hingestellt werden soll zuständig.
 

\section*{Probleme}
\subsection*{Routen können nicht richtig geplant werden}
\chapterauthor{Vanessa Hassouna}
Beim fahren fährt der Roboter schnell mit seinen Armen gegen Küchenobjekt und dreht sich in einem Winkel der problematisch mit seinem verletzbaren Rücken ist.\\


\textbf{Lösung}: Bevor er zu dem gegeben Punkt fährt, fährt er in eine von Uns ausgewählte sichere Position. Bis dahin sollte er sich um 90 Grad gedreht haben.

\subsection*{Extrahieren von wichtigen Information}
\chapterauthor{Vanessa Hassouna}
Bei dem Erhalt von Vision über die Informationen der gesehenen Objekte kommt eine sehr unübersichtliche \textbf{msg} die zerlegt werden muss. Hier kann es schnell zu Fehlern kommen, wenn man die Information als globale Variablen speichert. \\

\textbf{Lösung}: Alle erhaltenen Informationen werden zwischen gespeichert auf dem Paramserver, danach werden dieses erst miteinander konkateniert.

\subsection*{Logik der Main wird zu groß und unübersichtlich}
\chapterauthor{Vanessa Hassouna}
Für eine sinnvolle Logik der Main ist eine gute Übersicht zu schaffen. Da die Logik der Main jedoch immer fulminanter wird passiere hier schnell Fehler.\\

\textbf{Lösung}: Die Logik der Main wurde in mehrere Teilabschnitte getrennt und in neue Funktionen geschachtelt. Eine weitere Schnittstelle \textbf{planning\_logic} dient zur Extraktion von Logischen zwischen Abschnitten.

\section*{Architektur und Funktion}
\chapterauthor{Tammo Wübbena, Update: Alexander Link}
Das Vision-Paket \footnote{im weiteren Verlauf auch Vision-Package, vision-node oder einfach Paket oder vision genannt} dient zur Akquirierung und Verarbeitung visueller Informationen durch die Kinect-Kamera des PR2-Roboters.

%\begin{figure}[!htb]
   %     \center{\includegraphics[width=\textwidth]
  %      {figures/vision_suturo_node_diagram_demo2.png}
 %       \caption{\label{fig:vision_node} Architektur der vision-node}}
%\end{figure}
      
\section*{Methodendokumentation}

\subsection{planning\_main}

\subsubsection{main()}
\chapterauthor{Vanessa Hassouna}
\begin{verbatim}
main()
Beschreibung: Ablauf des Roboters
\end{verbatim}



\subsection{planning\_logic}

\subsubsection{transformation-Vision-Point (pose amount\\
\&optional (endFrame "/base\_footprint")}
\chapterauthor{Vanessa Hassouna}
\begin{verbatim}
transformation-Vision-Point (pose amount &optional (endFrame "/base\_footprint")
Beschreibung: Das gegeben Objekt wird von dem ausgehenden Frame in ein optionalen Frame umgewandelt(bei default ist dieser base\footprint)
@param: pose, amount und optional endFrame
@return: Liefert eine transformierte tf-point-stamped
\end{verbatim}




\subsubsection{catch-Transformation \\
(transform-listener tf-point-stamped endFrame)}
\chapterauthor{Vanessa Hassouna}
\begin{verbatim}
catch-Transformation (transform-listener tf-point-stamped endFrame)
Beschreibung: Hier findet die eigentliche transformation statt.
@param: transform-listener tf-point-stamped endFrame
@return: Liefert eine transformierte tf-point-stamped
\end{verbatim}


% KOMMT NOCH(defun let-Robo-Try-To-Poke (point-for-motion number-for-arm)
%KOMMT NOCH (defun try-To-Poke-Different-Location(point-for-motion number-for-arm)


\subsubsection{should-Robo-Use-Left-Or-Right-Arm(pose amount \\
\&optional (endFrame "/base\_footprint"))}
\chapterauthor{Vanessa Hassouna}
\begin{verbatim}
should-Robo-Use-Left-Or-Right-Arm (pose amount &optional (endFrame "/base\_footprint"))
Beschreibung: Anhand der Y-Achse entscheidet der Roboter ob er den linken oder rechten Arm bewegen soll
@param: pose object-number &optional endFrame
@return: 3 oder 2 (3 = links 2 = Rechts)
\end{verbatim}


\subsubsection{disassemble-Vision-Call (visionclouds)}
\chapterauthor{Vanessa Hassouna}
\begin{verbatim}
disassemble-Vision-Call (visionclouds)
Beschreibung: Extrahiert alle Informationen aus der Visioncloud und speichert normal\_features, color\_features, object\_amount und object\_pose auf den Param-Server.
@param: visionclouds
@return: object\_pose
\end{verbatim}



\subsubsection{set-Params-Features \\
(normal-s color-s normal-e color-e amount)}
\chapterauthor{Vanessa Hassouna}
\begin{verbatim}
set-Params-Features (normal-s color-s normal-e color-e amount)
Beschreibung: Hilfsfunktion für disassemble-Vision-Call um aus normal\_features und color\_features Konkateniert ein features-X zu erstellen. 
@param: normal-s color-s normal-e color-e amount
@return: Nil
\end{verbatim}


\subsubsection{init-pr2()}
\chapterauthor{Vanessa Hassouna}
\begin{verbatim}
init-pr2 ()
Beschreibung: Hört auf ein Topic Namens "/robot_pose" und bindet die Information.
@return: geometry_msgs/Pose
\end{verbatim}

\subsubsection{pose-cb (msg)}
\chapterauthor{Vanessa Hassouna}
\begin{verbatim}
pose-cb (msg)
Beschreibung: Rückrufende Funktion. Der Wert von msg wird als fluent *pr2-pose* gespeichjert.
@param: msg
@return: geometry_msgs/Pose
\end{verbatim}

\subsubsection{move-pr2 (x y z)}
\chapterauthor{Vanessa Hassouna}
\begin{verbatim}
move-pr2 (x y z)
Beschreibung: Ruft move-Base-To-Point-Safe mit angle-From-Pr2-Pose-To-Point auf.
@param: x y z 
@return: Succesfull oder Aborted
\end{verbatim}

\subsubsection{angle-From-Pr2-Pose-To-Point (x-goal y-goal z-goal)}
\chapterauthor{Vanessa Hassouna}
\begin{verbatim}
angle-From-Pr2-Pose-To-Point (x-goal y-goal z-goal)
Beschreibung: Berechnet von der aktuellen Position des Roboters um wie viel Grad er sich drehen muss um zu einem Punkt zu fahren, dafür wurde unter anderem das Packet "Cram-Language" mit der Funktion atan benutzt. Da das Bewegen des Pr2 in dem Frame "map" stattfindet, wurde hier zusätzlich noch die aktuelle Drehung des Pr2 in der Welt festgestellt und diese dann mit dem Grad um wie viel er sich drehen muss gegengerechnet, sodass am Ende ein Angle produziert wird, der innerhalb des Frames "map" funktioniert. 
@param: x-goal y-goal z-goal 
@return: angle 
\end{verbatim}

\subsection{planning\_motion}

\subsubsection{call-Motion-\\
Move-Arm-Homeposition()}
\chapterauthor{Vanessa Hassouna und Hauke T..}
\begin{verbatim}
call-Motion-Move-Arm-Homeposition()
Beschreibung: Ruft den Actionserver von Motion auf und gibt ihnen den Befehl die Arme in die Homeposition zu fahren.
@return: Succesfull oder Aborted
\end{verbatim}





\subsubsection{call-Motion-\\
Move-Arm-To-Point \\(point-center-of-object\\ \&optional (x 3))
}
\chapterauthor{Vanessa Hassouna und Hauke T..}
\begin{verbatim}
call-Motion-Move-Arm-To-Point (point-center-of-object \&optional (x 3))
Beschreibung: Ruft den Actionserver von Motion auf und gibt ihnen den Befehl den Arm zu dem point-center-of-object zu fahren. Optional kann man den Arm hier auswählen, der bei default der rechte ist.
@param point-center-of-object &optional (x 3)
@return: Succesfull oder Aborted
\end{verbatim}


\subsection{planning\_move}

\subsubsection{move-Head (x y z))
}
\chapterauthor{Vanessa Hassouna und Kevin}
\begin{verbatim}
move-Head (x y z)
Beschreibung: Lässt den Rr2-Kopf bewegen, dabei wird der Service "head\_traj\_controller/point\_head\_action" angesprochen.
@param: x y z 
@return: Succesfull oder Aborted
\end{verbatim}



\subsubsection{move-Base-To-\\
Point-Safe (x y z angle))
}
\chapterauthor{Vanessa Hassouna}
\begin{verbatim}
move-Base-To-Point-Safe (x y z angle)
Beschreibung: Hier wird move-Base-To-Point aufgerufen, jedoch bevor dies mit den gegeben Punkten passiert, fährt er in eine von Uns definierte Position. Das stellt sicher, dass er nicht gegen Kanten stößt. 
@param: x y z angle
@return: Succesfull oder Aborted
\end{verbatim}


\subsubsection{move-Base-To-\\
Point (x y z angle)}
\chapterauthor{Vanessa Hassouna}
\begin{verbatim}
move-Base-To-Point (x y z angle)
Beschreibung: Anhand des  "nav\_pcontroller/move\_base" wird die Basis bewegt. Der Punkt und die Rotation sind in Frame "map" anzugeben.
@param: x y z angle
@return: Succesfull oder Aborted
\end{verbatim}




\subsubsection{move-Robo-Into\\
-Homeposition ()}
\chapterauthor{Vanessa Hassouna}
\begin{verbatim}
move-Robo-Into-Homeposition ()
Beschreibung: move-Base-To-Point wird aufgerufen mit von Uns vordefinierten Punkten die als Homeposition  definiert sind.
@return: Succesfull oder Aborted
\end{verbatim}


\subsubsection{init-Robo-Moving ()}
\chapterauthor{Vanessa Hassouna}
\begin{verbatim}
init-Robo-Moving ()
Beschreibung: Eine Hilfsfunktion die dazu dient, die initialisieren in der Simulation zu Übernehmen.
@return: Succesfull oder Aborted
\end{verbatim}

\subsubsection{init-Action-Client-Base ()}
\chapterauthor{Vanessa Hassouna}
\begin{verbatim}
init-Action-Client-Base ()
Beschreibung: Eine Hilfsfunktion die dazu dient, den Action-Client zu initialisieren.
@return: Succesfull oder Aborted
\end{verbatim}


\subsubsection{get-Action-Client-Base ()}
\chapterauthor{Vanessa Hassouna}
\begin{verbatim}
get-Action-Client-Base ()
Beschreibung: Eine Hilfsfunktion die dazu dient, den Action-Client zu erhalten.
@return: Succesfull oder Aborted
\end{verbatim}

\subsection{planning\_vision}

\subsubsection{call-Vision-Object-Clouds ()}
\chapterauthor{Vanessa Hassouna}
\begin{verbatim}
call-Vision-Object-Clouds ()
Beschreibung: Der Service von Vision  "/vision\_suturo/objects\_information" wird aufgerufen.
@return: Succesfull oder Aborted
\end{verbatim}




\section*{Programmablauf}
\chapterauthor{Vanessa Hassouna}
\subsection*{Schritt 1: Vorbereiten des Roboters}
Der Pr2 begibt sich in die Homeposition von der aus er Objekte sehen soll. 

\subsection*{Schritt 2: Suche nach Objekten}
Jedes mal, wenn der Kopf in einer Position ist wird der Service \textit{/vision\_suturo/objects\_information} aufgerufen. Die gegeben Information werden wie folgt bearbeitet:

\begin{itemize} 
\item Die Informationen werden extrahiert.
\item Die beiden Arrays normal\_features und color\_features werden auseinander genommen und mithilfe von object\_amount auf dem Param-Server gespeichert mit der Nummer des Objektes zu der Identifikation.
\item Die normal\_features und color\_features werden konkateniert auf dem Param-Server gespeichert als "featuresX", wobei X hier die Nummer des Objektes darstellt.
\item Die Posen werden als Array global gespeichert.
\end{itemize}


\subsection*{Schritt 3: Weitergabe} 

\begin{itemize} 
\item Jetzt werden die gesehenen Objekte weitergeben an Knowledge, hier bekommen wir für jedes gegebene Objekt ein Label als String zurück.
\item Mithilfe des erhaltenen Labels rufen wir einen anderen Service von Vision auf der Anhand von Objekt-Nummer und Label uns eine Pose zurück gibt.  
\item Wenn die Pose bei uns angekommen ist publishen wir auf ein Topic von Knowledge damit das gesehene Objekt in der Wissensbasis gespeichert wird.
\end{itemize}



\subsection*{Schritt 4: Welches Objekt soll ich greifen und wo soll es hin}
Wir erfragen bei Knowledge welche Objekte wir greifen sollen. %Hier kommt noch mehr
Mit der Funktion X kriegen wir dann einen Standpunkt raus wo das Objekt hin soll. %X=Hauke
Des weiteren wird noch abgefragt wie das Objekt gegriffen werden, soll. Die Information wird dann weiter an Motion gegeben.

\subsection*{Schritt 5: Hinfahren zum gegebenen Ort}
Mit Hilfe des Punktes wird berechnet wo der Roboter hinfahren muss. % hier noch mehr
 
\subsection*{Schritt 6: Abstellen und weiter}
Das Objekt wird abgestellt %Motion call. 
Danach fährt der Pr2 wieder zu seiner Homeposition und sucht die nächsten Objekte.


\section*{TODO: Zielsetzung, Ausblick}


\end{document}
